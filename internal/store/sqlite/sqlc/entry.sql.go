// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: entry.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addEntryLabelLink = `-- name: AddEntryLabelLink :execresult
INSERT INTO transaction_labels (transaction_id, label_id)
VALUES (?, ?)
`

type AddEntryLabelLinkParams struct {
	TransactionID int64 `json:"transaction_id"`
	LabelID       int64 `json:"label_id"`
}

func (q *Queries) AddEntryLabelLink(ctx context.Context, arg AddEntryLabelLinkParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addEntryLabelLink, arg.TransactionID, arg.LabelID)
}

const createEntry = `-- name: CreateEntry :execresult
INSERT INTO transactions (
    type,
    amount_minor,
    currency_code,
    transaction_date_utc,
    category_id,
    note
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateEntryParams struct {
	Type               string         `json:"type"`
	AmountMinor        int64          `json:"amount_minor"`
	CurrencyCode       string         `json:"currency_code"`
	TransactionDateUtc string         `json:"transaction_date_utc"`
	CategoryID         sql.NullInt64  `json:"category_id"`
	Note               sql.NullString `json:"note"`
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEntry,
		arg.Type,
		arg.AmountMinor,
		arg.CurrencyCode,
		arg.TransactionDateUtc,
		arg.CategoryID,
		arg.Note,
	)
}

const existsActiveCategoryByID = `-- name: ExistsActiveCategoryByID :one
SELECT EXISTS(
    SELECT 1
    FROM categories
    WHERE id = ? AND deleted_at_utc IS NULL
)
`

func (q *Queries) ExistsActiveCategoryByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsActiveCategoryByID, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const existsActiveLabelByID = `-- name: ExistsActiveLabelByID :one
SELECT EXISTS(
    SELECT 1
    FROM labels
    WHERE id = ? AND deleted_at_utc IS NULL
)
`

func (q *Queries) ExistsActiveLabelByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsActiveLabelByID, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getActiveEntryByID = `-- name: GetActiveEntryByID :one
SELECT id, type, amount_minor, currency_code, transaction_date_utc, category_id, note, created_at_utc, updated_at_utc, deleted_at_utc
FROM transactions
WHERE id = ? AND deleted_at_utc IS NULL
`

func (q *Queries) GetActiveEntryByID(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getActiveEntryByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.AmountMinor,
		&i.CurrencyCode,
		&i.TransactionDateUtc,
		&i.CategoryID,
		&i.Note,
		&i.CreatedAtUtc,
		&i.UpdatedAtUtc,
		&i.DeletedAtUtc,
	)
	return i, err
}

const listActiveEntries = `-- name: ListActiveEntries :many
SELECT id, type, amount_minor, currency_code, transaction_date_utc, category_id, note, created_at_utc, updated_at_utc, deleted_at_utc
FROM transactions
WHERE deleted_at_utc IS NULL
  AND (?1 IS NULL OR type = ?1)
  AND (?2 IS NULL OR category_id = ?2)
  AND (?3 IS NULL OR transaction_date_utc >= ?3)
  AND (?4 IS NULL OR transaction_date_utc <= ?4)
ORDER BY transaction_date_utc, id
`

type ListActiveEntriesParams struct {
	EntryType   interface{} `json:"entry_type"`
	CategoryID  interface{} `json:"category_id"`
	DateFromUtc interface{} `json:"date_from_utc"`
	DateToUtc   interface{} `json:"date_to_utc"`
}

func (q *Queries) ListActiveEntries(ctx context.Context, arg ListActiveEntriesParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listActiveEntries,
		arg.EntryType,
		arg.CategoryID,
		arg.DateFromUtc,
		arg.DateToUtc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.AmountMinor,
			&i.CurrencyCode,
			&i.TransactionDateUtc,
			&i.CategoryID,
			&i.Note,
			&i.CreatedAtUtc,
			&i.UpdatedAtUtc,
			&i.DeletedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveEntryLabelIDs = `-- name: ListActiveEntryLabelIDs :many
SELECT transaction_id, label_id
FROM transaction_labels
WHERE transaction_id = ? AND deleted_at_utc IS NULL
ORDER BY label_id
`

type ListActiveEntryLabelIDsRow struct {
	TransactionID int64 `json:"transaction_id"`
	LabelID       int64 `json:"label_id"`
}

func (q *Queries) ListActiveEntryLabelIDs(ctx context.Context, transactionID int64) ([]ListActiveEntryLabelIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveEntryLabelIDs, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveEntryLabelIDsRow
	for rows.Next() {
		var i ListActiveEntryLabelIDsRow
		if err := rows.Scan(&i.TransactionID, &i.LabelID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteEntry = `-- name: SoftDeleteEntry :execresult
UPDATE transactions
SET deleted_at_utc = ?, updated_at_utc = ?
WHERE id = ? AND deleted_at_utc IS NULL
`

type SoftDeleteEntryParams struct {
	DeletedAtUtc sql.NullString `json:"deleted_at_utc"`
	UpdatedAtUtc string         `json:"updated_at_utc"`
	ID           int64          `json:"id"`
}

func (q *Queries) SoftDeleteEntry(ctx context.Context, arg SoftDeleteEntryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, softDeleteEntry, arg.DeletedAtUtc, arg.UpdatedAtUtc, arg.ID)
}

const softDeleteEntryLabelLinks = `-- name: SoftDeleteEntryLabelLinks :execresult
UPDATE transaction_labels
SET deleted_at_utc = ?
WHERE transaction_id = ? AND deleted_at_utc IS NULL
`

type SoftDeleteEntryLabelLinksParams struct {
	DeletedAtUtc  sql.NullString `json:"deleted_at_utc"`
	TransactionID int64          `json:"transaction_id"`
}

func (q *Queries) SoftDeleteEntryLabelLinks(ctx context.Context, arg SoftDeleteEntryLabelLinksParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, softDeleteEntryLabelLinks, arg.DeletedAtUtc, arg.TransactionID)
}
