// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: entry.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addEntryLabelLink = `-- name: AddEntryLabelLink :execresult
INSERT INTO transaction_labels (transaction_id, label_id)
VALUES (?, ?)
`

type AddEntryLabelLinkParams struct {
	TransactionID int64 `json:"transaction_id"`
	LabelID       int64 `json:"label_id"`
}

func (q *Queries) AddEntryLabelLink(ctx context.Context, arg AddEntryLabelLinkParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addEntryLabelLink, arg.TransactionID, arg.LabelID)
}

const createEntry = `-- name: CreateEntry :execresult
INSERT INTO transactions (
    type,
    amount_minor,
    currency_code,
    transaction_date_utc,
    category_id,
    note
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateEntryParams struct {
	Type               string         `json:"type"`
	AmountMinor        int64          `json:"amount_minor"`
	CurrencyCode       string         `json:"currency_code"`
	TransactionDateUtc string         `json:"transaction_date_utc"`
	CategoryID         sql.NullInt64  `json:"category_id"`
	Note               sql.NullString `json:"note"`
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEntry,
		arg.Type,
		arg.AmountMinor,
		arg.CurrencyCode,
		arg.TransactionDateUtc,
		arg.CategoryID,
		arg.Note,
	)
}

const existsActiveCategoryByID = `-- name: ExistsActiveCategoryByID :one
SELECT EXISTS(
    SELECT 1
    FROM categories
    WHERE id = ? AND deleted_at_utc IS NULL
)
`

func (q *Queries) ExistsActiveCategoryByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsActiveCategoryByID, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const existsActiveLabelByID = `-- name: ExistsActiveLabelByID :one
SELECT EXISTS(
    SELECT 1
    FROM labels
    WHERE id = ? AND deleted_at_utc IS NULL
)
`

func (q *Queries) ExistsActiveLabelByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsActiveLabelByID, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getActiveEntryByID = `-- name: GetActiveEntryByID :one
SELECT id, type, amount_minor, currency_code, transaction_date_utc, category_id, note, created_at_utc, updated_at_utc, deleted_at_utc
FROM transactions
WHERE id = ? AND deleted_at_utc IS NULL
`

func (q *Queries) GetActiveEntryByID(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getActiveEntryByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.AmountMinor,
		&i.CurrencyCode,
		&i.TransactionDateUtc,
		&i.CategoryID,
		&i.Note,
		&i.CreatedAtUtc,
		&i.UpdatedAtUtc,
		&i.DeletedAtUtc,
	)
	return i, err
}

const listActiveEntries = `-- name: ListActiveEntries :many
SELECT id, type, amount_minor, currency_code, transaction_date_utc, category_id, note, created_at_utc, updated_at_utc, deleted_at_utc
FROM transactions
WHERE deleted_at_utc IS NULL
  AND (?1 IS NULL OR type = ?1)
  AND (?2 IS NULL OR category_id = ?2)
  AND (?3 IS NULL OR transaction_date_utc >= ?3)
  AND (?4 IS NULL OR transaction_date_utc <= ?4)
  AND (?5 IS NULL OR (note IS NOT NULL AND instr(lower(note), lower(?5)) > 0))
ORDER BY transaction_date_utc, id
`

type ListActiveEntriesParams struct {
	EntryType    interface{} `json:"entry_type"`
	CategoryID   interface{} `json:"category_id"`
	DateFromUtc  interface{} `json:"date_from_utc"`
	DateToUtc    interface{} `json:"date_to_utc"`
	NoteContains interface{} `json:"note_contains"`
}

func (q *Queries) ListActiveEntries(ctx context.Context, arg ListActiveEntriesParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listActiveEntries,
		arg.EntryType,
		arg.CategoryID,
		arg.DateFromUtc,
		arg.DateToUtc,
		arg.NoteContains,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.AmountMinor,
			&i.CurrencyCode,
			&i.TransactionDateUtc,
			&i.CategoryID,
			&i.Note,
			&i.CreatedAtUtc,
			&i.UpdatedAtUtc,
			&i.DeletedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveEntryLabelIDs = `-- name: ListActiveEntryLabelIDs :many
SELECT transaction_id, label_id
FROM transaction_labels
WHERE transaction_id = ? AND deleted_at_utc IS NULL
ORDER BY label_id
`

type ListActiveEntryLabelIDsRow struct {
	TransactionID int64 `json:"transaction_id"`
	LabelID       int64 `json:"label_id"`
}

func (q *Queries) ListActiveEntryLabelIDs(ctx context.Context, transactionID int64) ([]ListActiveEntryLabelIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveEntryLabelIDs, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveEntryLabelIDsRow
	for rows.Next() {
		var i ListActiveEntryLabelIDsRow
		if err := rows.Scan(&i.TransactionID, &i.LabelID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveEntryLabelIDsForListFilter = `-- name: ListActiveEntryLabelIDsForListFilter :many
SELECT tl.transaction_id, tl.label_id
FROM transaction_labels tl
INNER JOIN transactions t ON t.id = tl.transaction_id
WHERE tl.deleted_at_utc IS NULL
  AND t.deleted_at_utc IS NULL
  AND (?1 IS NULL OR t.type = ?1)
  AND (?2 IS NULL OR t.category_id = ?2)
  AND (?3 IS NULL OR t.transaction_date_utc >= ?3)
  AND (?4 IS NULL OR t.transaction_date_utc <= ?4)
  AND (?5 IS NULL OR (t.note IS NOT NULL AND instr(lower(t.note), lower(?5)) > 0))
ORDER BY tl.transaction_id, tl.label_id
`

type ListActiveEntryLabelIDsForListFilterParams struct {
	EntryType    interface{} `json:"entry_type"`
	CategoryID   interface{} `json:"category_id"`
	DateFromUtc  interface{} `json:"date_from_utc"`
	DateToUtc    interface{} `json:"date_to_utc"`
	NoteContains interface{} `json:"note_contains"`
}

type ListActiveEntryLabelIDsForListFilterRow struct {
	TransactionID int64 `json:"transaction_id"`
	LabelID       int64 `json:"label_id"`
}

func (q *Queries) ListActiveEntryLabelIDsForListFilter(ctx context.Context, arg ListActiveEntryLabelIDsForListFilterParams) ([]ListActiveEntryLabelIDsForListFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveEntryLabelIDsForListFilter,
		arg.EntryType,
		arg.CategoryID,
		arg.DateFromUtc,
		arg.DateToUtc,
		arg.NoteContains,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveEntryLabelIDsForListFilterRow
	for rows.Next() {
		var i ListActiveEntryLabelIDsForListFilterRow
		if err := rows.Scan(&i.TransactionID, &i.LabelID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteEntry = `-- name: SoftDeleteEntry :execresult
UPDATE transactions
SET deleted_at_utc = ?, updated_at_utc = ?
WHERE id = ? AND deleted_at_utc IS NULL
`

type SoftDeleteEntryParams struct {
	DeletedAtUtc sql.NullString `json:"deleted_at_utc"`
	UpdatedAtUtc string         `json:"updated_at_utc"`
	ID           int64          `json:"id"`
}

func (q *Queries) SoftDeleteEntry(ctx context.Context, arg SoftDeleteEntryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, softDeleteEntry, arg.DeletedAtUtc, arg.UpdatedAtUtc, arg.ID)
}

const softDeleteEntryLabelLinks = `-- name: SoftDeleteEntryLabelLinks :execresult
UPDATE transaction_labels
SET deleted_at_utc = ?
WHERE transaction_id = ? AND deleted_at_utc IS NULL
`

type SoftDeleteEntryLabelLinksParams struct {
	DeletedAtUtc  sql.NullString `json:"deleted_at_utc"`
	TransactionID int64          `json:"transaction_id"`
}

func (q *Queries) SoftDeleteEntryLabelLinks(ctx context.Context, arg SoftDeleteEntryLabelLinksParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, softDeleteEntryLabelLinks, arg.DeletedAtUtc, arg.TransactionID)
}

const updateEntryByID = `-- name: UpdateEntryByID :execresult
UPDATE transactions
SET type = CASE
    WHEN ?1 = 1 THEN ?2
    ELSE type
END,
    amount_minor = CASE
    WHEN ?3 = 1 THEN ?4
    ELSE amount_minor
END,
    currency_code = CASE
    WHEN ?5 = 1 THEN ?6
    ELSE currency_code
END,
    transaction_date_utc = CASE
    WHEN ?7 = 1 THEN ?8
    ELSE transaction_date_utc
END,
    category_id = CASE
    WHEN ?9 = 1 THEN NULL
    WHEN ?10 = 1 THEN ?11
    ELSE category_id
END,
    note = CASE
    WHEN ?12 = 1 THEN NULL
    WHEN ?13 = 1 THEN ?14
    ELSE note
END,
    updated_at_utc = ?15
WHERE id = ?16
  AND deleted_at_utc IS NULL
`

type UpdateEntryByIDParams struct {
	SetType               interface{}    `json:"set_type"`
	Type                  string         `json:"type"`
	SetAmountMinor        interface{}    `json:"set_amount_minor"`
	AmountMinor           int64          `json:"amount_minor"`
	SetCurrencyCode       interface{}    `json:"set_currency_code"`
	CurrencyCode          string         `json:"currency_code"`
	SetTransactionDateUtc interface{}    `json:"set_transaction_date_utc"`
	TransactionDateUtc    string         `json:"transaction_date_utc"`
	ClearCategory         interface{}    `json:"clear_category"`
	SetCategoryID         interface{}    `json:"set_category_id"`
	CategoryID            sql.NullInt64  `json:"category_id"`
	ClearNote             interface{}    `json:"clear_note"`
	SetNote               interface{}    `json:"set_note"`
	Note                  sql.NullString `json:"note"`
	UpdatedAtUtc          string         `json:"updated_at_utc"`
	ID                    int64          `json:"id"`
}

func (q *Queries) UpdateEntryByID(ctx context.Context, arg UpdateEntryByIDParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateEntryByID,
		arg.SetType,
		arg.Type,
		arg.SetAmountMinor,
		arg.AmountMinor,
		arg.SetCurrencyCode,
		arg.CurrencyCode,
		arg.SetTransactionDateUtc,
		arg.TransactionDateUtc,
		arg.ClearCategory,
		arg.SetCategoryID,
		arg.CategoryID,
		arg.ClearNote,
		arg.SetNote,
		arg.Note,
		arg.UpdatedAtUtc,
		arg.ID,
	)
}
