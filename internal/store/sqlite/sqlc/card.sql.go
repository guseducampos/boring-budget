// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: card.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createCard = `-- name: CreateCard :execresult
INSERT INTO cards (
    nickname,
    description,
    last4,
    brand,
    card_type,
    due_day,
    updated_at_utc
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateCardParams struct {
	Nickname     string         `json:"nickname"`
	Description  sql.NullString `json:"description"`
	Last4        string         `json:"last4"`
	Brand        string         `json:"brand"`
	CardType     string         `json:"card_type"`
	DueDay       sql.NullInt64  `json:"due_day"`
	UpdatedAtUtc string         `json:"updated_at_utc"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCard,
		arg.Nickname,
		arg.Description,
		arg.Last4,
		arg.Brand,
		arg.CardType,
		arg.DueDay,
		arg.UpdatedAtUtc,
	)
}

const createCreditLiabilityEvent = `-- name: CreateCreditLiabilityEvent :execresult
INSERT INTO credit_liability_events (
    card_id,
    currency_code,
    event_type,
    amount_minor_signed,
    reference_transaction_id,
    note,
    created_at_utc
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateCreditLiabilityEventParams struct {
	CardID                 int64          `json:"card_id"`
	CurrencyCode           string         `json:"currency_code"`
	EventType              string         `json:"event_type"`
	AmountMinorSigned      int64          `json:"amount_minor_signed"`
	ReferenceTransactionID sql.NullInt64  `json:"reference_transaction_id"`
	Note                   sql.NullString `json:"note"`
	CreatedAtUtc           string         `json:"created_at_utc"`
}

func (q *Queries) CreateCreditLiabilityEvent(ctx context.Context, arg CreateCreditLiabilityEventParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCreditLiabilityEvent,
		arg.CardID,
		arg.CurrencyCode,
		arg.EventType,
		arg.AmountMinorSigned,
		arg.ReferenceTransactionID,
		arg.Note,
		arg.CreatedAtUtc,
	)
}

const deleteCreditLiabilityEventsByReferenceTransaction = `-- name: DeleteCreditLiabilityEventsByReferenceTransaction :execresult
DELETE FROM credit_liability_events
WHERE reference_transaction_id = ?
`

func (q *Queries) DeleteCreditLiabilityEventsByReferenceTransaction(ctx context.Context, referenceTransactionID sql.NullInt64) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteCreditLiabilityEventsByReferenceTransaction, referenceTransactionID)
}

const existsActiveCardByID = `-- name: ExistsActiveCardByID :one
SELECT EXISTS(
    SELECT 1
    FROM cards
    WHERE id = ?
      AND deleted_at_utc IS NULL
)
`

func (q *Queries) ExistsActiveCardByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsActiveCardByID, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const existsCardByID = `-- name: ExistsCardByID :one
SELECT EXISTS(
    SELECT 1
    FROM cards
    WHERE id = ?
)
`

func (q *Queries) ExistsCardByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsCardByID, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const existsTransactionByID = `-- name: ExistsTransactionByID :one
SELECT EXISTS(
    SELECT 1
    FROM transactions
    WHERE id = ?
)
`

func (q *Queries) ExistsTransactionByID(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsTransactionByID, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getActiveCardByID = `-- name: GetActiveCardByID :one
SELECT id, nickname, description, last4, brand, card_type, due_day, created_at_utc, updated_at_utc, deleted_at_utc
FROM cards
WHERE id = ?
  AND deleted_at_utc IS NULL
`

func (q *Queries) GetActiveCardByID(ctx context.Context, id int64) (Card, error) {
	row := q.db.QueryRowContext(ctx, getActiveCardByID, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Nickname,
		&i.Description,
		&i.Last4,
		&i.Brand,
		&i.CardType,
		&i.DueDay,
		&i.CreatedAtUtc,
		&i.UpdatedAtUtc,
		&i.DeletedAtUtc,
	)
	return i, err
}

const getActiveCardByNickname = `-- name: GetActiveCardByNickname :one
SELECT id, nickname, description, last4, brand, card_type, due_day, created_at_utc, updated_at_utc, deleted_at_utc
FROM cards
WHERE lower(nickname) = lower(?)
  AND deleted_at_utc IS NULL
`

func (q *Queries) GetActiveCardByNickname(ctx context.Context, lower string) (Card, error) {
	row := q.db.QueryRowContext(ctx, getActiveCardByNickname, lower)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Nickname,
		&i.Description,
		&i.Last4,
		&i.Brand,
		&i.CardType,
		&i.DueDay,
		&i.CreatedAtUtc,
		&i.UpdatedAtUtc,
		&i.DeletedAtUtc,
	)
	return i, err
}

const getActiveCardDueByID = `-- name: GetActiveCardDueByID :one
SELECT id, nickname, due_day
FROM cards
WHERE id = ?
  AND deleted_at_utc IS NULL
  AND card_type = 'credit'
`

type GetActiveCardDueByIDRow struct {
	ID       int64         `json:"id"`
	Nickname string        `json:"nickname"`
	DueDay   sql.NullInt64 `json:"due_day"`
}

func (q *Queries) GetActiveCardDueByID(ctx context.Context, id int64) (GetActiveCardDueByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveCardDueByID, id)
	var i GetActiveCardDueByIDRow
	err := row.Scan(&i.ID, &i.Nickname, &i.DueDay)
	return i, err
}

const getCardByID = `-- name: GetCardByID :one
SELECT id, nickname, description, last4, brand, card_type, due_day, created_at_utc, updated_at_utc, deleted_at_utc
FROM cards
WHERE id = ?
`

func (q *Queries) GetCardByID(ctx context.Context, id int64) (Card, error) {
	row := q.db.QueryRowContext(ctx, getCardByID, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Nickname,
		&i.Description,
		&i.Last4,
		&i.Brand,
		&i.CardType,
		&i.DueDay,
		&i.CreatedAtUtc,
		&i.UpdatedAtUtc,
		&i.DeletedAtUtc,
	)
	return i, err
}

const getCreditLiabilityBalanceByCardAndCurrency = `-- name: GetCreditLiabilityBalanceByCardAndCurrency :one
SELECT CAST(COALESCE(SUM(amount_minor_signed), 0) AS INTEGER) AS balance_minor
FROM credit_liability_events
WHERE card_id = ?
  AND currency_code = ?
`

type GetCreditLiabilityBalanceByCardAndCurrencyParams struct {
	CardID       int64  `json:"card_id"`
	CurrencyCode string `json:"currency_code"`
}

func (q *Queries) GetCreditLiabilityBalanceByCardAndCurrency(ctx context.Context, arg GetCreditLiabilityBalanceByCardAndCurrencyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCreditLiabilityBalanceByCardAndCurrency, arg.CardID, arg.CurrencyCode)
	var balance_minor int64
	err := row.Scan(&balance_minor)
	return balance_minor, err
}

const getCreditLiabilityEventByID = `-- name: GetCreditLiabilityEventByID :one
SELECT id, card_id, currency_code, event_type, amount_minor_signed, reference_transaction_id, note, created_at_utc
FROM credit_liability_events
WHERE id = ?
`

func (q *Queries) GetCreditLiabilityEventByID(ctx context.Context, id int64) (CreditLiabilityEvent, error) {
	row := q.db.QueryRowContext(ctx, getCreditLiabilityEventByID, id)
	var i CreditLiabilityEvent
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.CurrencyCode,
		&i.EventType,
		&i.AmountMinorSigned,
		&i.ReferenceTransactionID,
		&i.Note,
		&i.CreatedAtUtc,
	)
	return i, err
}

const getTransactionPaymentMethodByTransactionID = `-- name: GetTransactionPaymentMethodByTransactionID :one
SELECT transaction_id, method_type, card_id, created_at_utc, updated_at_utc
FROM transaction_payment_methods
WHERE transaction_id = ?
`

func (q *Queries) GetTransactionPaymentMethodByTransactionID(ctx context.Context, transactionID int64) (TransactionPaymentMethod, error) {
	row := q.db.QueryRowContext(ctx, getTransactionPaymentMethodByTransactionID, transactionID)
	var i TransactionPaymentMethod
	err := row.Scan(
		&i.TransactionID,
		&i.MethodType,
		&i.CardID,
		&i.CreatedAtUtc,
		&i.UpdatedAtUtc,
	)
	return i, err
}

const listActiveCreditCardDues = `-- name: ListActiveCreditCardDues :many
SELECT id, nickname, due_day
FROM cards
WHERE deleted_at_utc IS NULL
  AND card_type = 'credit'
ORDER BY due_day, id
`

type ListActiveCreditCardDuesRow struct {
	ID       int64         `json:"id"`
	Nickname string        `json:"nickname"`
	DueDay   sql.NullInt64 `json:"due_day"`
}

func (q *Queries) ListActiveCreditCardDues(ctx context.Context) ([]ListActiveCreditCardDuesRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveCreditCardDues)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveCreditCardDuesRow
	for rows.Next() {
		var i ListActiveCreditCardDuesRow
		if err := rows.Scan(&i.ID, &i.Nickname, &i.DueDay); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCards = `-- name: ListCards :many
SELECT id, nickname, description, last4, brand, card_type, due_day, created_at_utc, updated_at_utc, deleted_at_utc
FROM cards
WHERE (?1 = 1 OR deleted_at_utc IS NULL)
  AND (?2 IS NULL OR card_type = ?2)
ORDER BY lower(nickname), id
`

type ListCardsParams struct {
	IncludeDeleted interface{} `json:"include_deleted"`
	CardType       interface{} `json:"card_type"`
}

func (q *Queries) ListCards(ctx context.Context, arg ListCardsParams) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listCards, arg.IncludeDeleted, arg.CardType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.Nickname,
			&i.Description,
			&i.Last4,
			&i.Brand,
			&i.CardType,
			&i.DueDay,
			&i.CreatedAtUtc,
			&i.UpdatedAtUtc,
			&i.DeletedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCreditLiabilityEventsByCard = `-- name: ListCreditLiabilityEventsByCard :many
SELECT id, card_id, currency_code, event_type, amount_minor_signed, reference_transaction_id, note, created_at_utc
FROM credit_liability_events
WHERE card_id = ?
ORDER BY currency_code, created_at_utc, id
`

func (q *Queries) ListCreditLiabilityEventsByCard(ctx context.Context, cardID int64) ([]CreditLiabilityEvent, error) {
	rows, err := q.db.QueryContext(ctx, listCreditLiabilityEventsByCard, cardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CreditLiabilityEvent
	for rows.Next() {
		var i CreditLiabilityEvent
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.CurrencyCode,
			&i.EventType,
			&i.AmountMinorSigned,
			&i.ReferenceTransactionID,
			&i.Note,
			&i.CreatedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCreditLiabilityEventsByCardAndCurrency = `-- name: ListCreditLiabilityEventsByCardAndCurrency :many
SELECT id, card_id, currency_code, event_type, amount_minor_signed, reference_transaction_id, note, created_at_utc
FROM credit_liability_events
WHERE card_id = ?
  AND currency_code = ?
ORDER BY created_at_utc, id
`

type ListCreditLiabilityEventsByCardAndCurrencyParams struct {
	CardID       int64  `json:"card_id"`
	CurrencyCode string `json:"currency_code"`
}

func (q *Queries) ListCreditLiabilityEventsByCardAndCurrency(ctx context.Context, arg ListCreditLiabilityEventsByCardAndCurrencyParams) ([]CreditLiabilityEvent, error) {
	rows, err := q.db.QueryContext(ctx, listCreditLiabilityEventsByCardAndCurrency, arg.CardID, arg.CurrencyCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CreditLiabilityEvent
	for rows.Next() {
		var i CreditLiabilityEvent
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.CurrencyCode,
			&i.EventType,
			&i.AmountMinorSigned,
			&i.ReferenceTransactionID,
			&i.Note,
			&i.CreatedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCreditLiabilitySummaryAllCards = `-- name: ListCreditLiabilitySummaryAllCards :many
SELECT card_id,
       currency_code,
       CAST(COALESCE(SUM(amount_minor_signed), 0) AS INTEGER) AS balance_minor,
       MAX(created_at_utc) AS last_event_at_utc
FROM credit_liability_events
GROUP BY card_id, currency_code
ORDER BY card_id, currency_code
`

type ListCreditLiabilitySummaryAllCardsRow struct {
	CardID         int64       `json:"card_id"`
	CurrencyCode   string      `json:"currency_code"`
	BalanceMinor   int64       `json:"balance_minor"`
	LastEventAtUtc interface{} `json:"last_event_at_utc"`
}

func (q *Queries) ListCreditLiabilitySummaryAllCards(ctx context.Context) ([]ListCreditLiabilitySummaryAllCardsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCreditLiabilitySummaryAllCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCreditLiabilitySummaryAllCardsRow
	for rows.Next() {
		var i ListCreditLiabilitySummaryAllCardsRow
		if err := rows.Scan(
			&i.CardID,
			&i.CurrencyCode,
			&i.BalanceMinor,
			&i.LastEventAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCreditLiabilitySummaryByCard = `-- name: ListCreditLiabilitySummaryByCard :many
SELECT card_id,
       currency_code,
       CAST(COALESCE(SUM(amount_minor_signed), 0) AS INTEGER) AS balance_minor,
       MAX(created_at_utc) AS last_event_at_utc
FROM credit_liability_events
WHERE card_id = ?
GROUP BY card_id, currency_code
ORDER BY currency_code
`

type ListCreditLiabilitySummaryByCardRow struct {
	CardID         int64       `json:"card_id"`
	CurrencyCode   string      `json:"currency_code"`
	BalanceMinor   int64       `json:"balance_minor"`
	LastEventAtUtc interface{} `json:"last_event_at_utc"`
}

func (q *Queries) ListCreditLiabilitySummaryByCard(ctx context.Context, cardID int64) ([]ListCreditLiabilitySummaryByCardRow, error) {
	rows, err := q.db.QueryContext(ctx, listCreditLiabilitySummaryByCard, cardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCreditLiabilitySummaryByCardRow
	for rows.Next() {
		var i ListCreditLiabilitySummaryByCardRow
		if err := rows.Scan(
			&i.CardID,
			&i.CurrencyCode,
			&i.BalanceMinor,
			&i.LastEventAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchActiveCardsByLookup = `-- name: SearchActiveCardsByLookup :many
SELECT id, nickname, description, last4, brand, card_type, due_day, created_at_utc, updated_at_utc, deleted_at_utc
FROM cards
WHERE deleted_at_utc IS NULL
  AND (
      instr(lower(nickname), lower(?1)) > 0
      OR (description IS NOT NULL AND instr(lower(description), lower(?1)) > 0)
      OR instr(last4, ?1) > 0
  )
ORDER BY lower(nickname), id
LIMIT ?2
`

type SearchActiveCardsByLookupParams struct {
	LookupText string `json:"lookup_text"`
	LimitRows  int64  `json:"limit_rows"`
}

func (q *Queries) SearchActiveCardsByLookup(ctx context.Context, arg SearchActiveCardsByLookupParams) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, searchActiveCardsByLookup, arg.LookupText, arg.LimitRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.Nickname,
			&i.Description,
			&i.Last4,
			&i.Brand,
			&i.CardType,
			&i.DueDay,
			&i.CreatedAtUtc,
			&i.UpdatedAtUtc,
			&i.DeletedAtUtc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteCard = `-- name: SoftDeleteCard :execresult
UPDATE cards
SET deleted_at_utc = ?,
    updated_at_utc = ?
WHERE id = ?
  AND deleted_at_utc IS NULL
`

type SoftDeleteCardParams struct {
	DeletedAtUtc sql.NullString `json:"deleted_at_utc"`
	UpdatedAtUtc string         `json:"updated_at_utc"`
	ID           int64          `json:"id"`
}

func (q *Queries) SoftDeleteCard(ctx context.Context, arg SoftDeleteCardParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, softDeleteCard, arg.DeletedAtUtc, arg.UpdatedAtUtc, arg.ID)
}

const updateCardByID = `-- name: UpdateCardByID :execresult
UPDATE cards
SET nickname = CASE
    WHEN ?1 = 1 THEN ?2
    ELSE nickname
END,
    description = CASE
    WHEN ?3 = 1 THEN NULL
    WHEN ?4 = 1 THEN ?5
    ELSE description
END,
    last4 = CASE
    WHEN ?6 = 1 THEN ?7
    ELSE last4
END,
    brand = CASE
    WHEN ?8 = 1 THEN ?9
    ELSE brand
END,
    card_type = CASE
    WHEN ?10 = 1 THEN ?11
    ELSE card_type
END,
    due_day = CASE
    WHEN ?12 = 1 THEN NULL
    WHEN ?13 = 1 THEN ?14
    ELSE due_day
END,
    updated_at_utc = ?15
WHERE id = ?16
  AND deleted_at_utc IS NULL
`

type UpdateCardByIDParams struct {
	SetNickname      interface{}    `json:"set_nickname"`
	Nickname         string         `json:"nickname"`
	ClearDescription interface{}    `json:"clear_description"`
	SetDescription   interface{}    `json:"set_description"`
	Description      sql.NullString `json:"description"`
	SetLast4         interface{}    `json:"set_last4"`
	Last4            string         `json:"last4"`
	SetBrand         interface{}    `json:"set_brand"`
	Brand            string         `json:"brand"`
	SetCardType      interface{}    `json:"set_card_type"`
	CardType         string         `json:"card_type"`
	ClearDueDay      interface{}    `json:"clear_due_day"`
	SetDueDay        interface{}    `json:"set_due_day"`
	DueDay           sql.NullInt64  `json:"due_day"`
	UpdatedAtUtc     string         `json:"updated_at_utc"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateCardByID(ctx context.Context, arg UpdateCardByIDParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateCardByID,
		arg.SetNickname,
		arg.Nickname,
		arg.ClearDescription,
		arg.SetDescription,
		arg.Description,
		arg.SetLast4,
		arg.Last4,
		arg.SetBrand,
		arg.Brand,
		arg.SetCardType,
		arg.CardType,
		arg.ClearDueDay,
		arg.SetDueDay,
		arg.DueDay,
		arg.UpdatedAtUtc,
		arg.ID,
	)
}

const upsertTransactionPaymentMethod = `-- name: UpsertTransactionPaymentMethod :execresult
INSERT INTO transaction_payment_methods (
    transaction_id,
    method_type,
    card_id,
    updated_at_utc
) VALUES (?, ?, ?, ?)
ON CONFLICT(transaction_id)
DO UPDATE SET
    method_type = excluded.method_type,
    card_id = excluded.card_id,
    updated_at_utc = excluded.updated_at_utc
`

type UpsertTransactionPaymentMethodParams struct {
	TransactionID int64         `json:"transaction_id"`
	MethodType    string        `json:"method_type"`
	CardID        sql.NullInt64 `json:"card_id"`
	UpdatedAtUtc  string        `json:"updated_at_utc"`
}

func (q *Queries) UpsertTransactionPaymentMethod(ctx context.Context, arg UpsertTransactionPaymentMethodParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, upsertTransactionPaymentMethod,
		arg.TransactionID,
		arg.MethodType,
		arg.CardID,
		arg.UpdatedAtUtc,
	)
}
